# Обзор

Код для работы с математическими выражениями в **инфиксной и постфиксной нотации**, реализующий следующие основные операции:

1. **Преобразование инфиксной нотации в постфиксную** (Обратная польская нотация)
2. **Вычисление постфиксного выражения**
3. **Построение графика** математического выражения в заданном диапазоне

Код написан на языке C и использует стековый подход.

## Оглавление

1. [Особенности](#особенности)
    - [Преобразование из инфиксной в постфиксную нотацию](#1-преобразование-из-инфиксной-в-постфиксную-нотацию)
    - [Вычисление постфиксного выражения](#2-вычисление-постфиксного-выражения)
    - [Построение графиков](#3-построение-графиков)
2. [Структура проекта](#структура-проекта)
3. [Ввод исходной строки](#ввод-исходной-строки)
4. [Алгоритм Дейкстры - Конвертация инфиксной записи в постфиксную](#алгоритм-дейкстры---конвертация-инфиксной-записи-в-постфиксную)
    - [Проверка логической корректности выражения](#проверка-логической-корректности-выражения)
    - [Реализация алгоритма Дейкстры](#реализация-алгоритма-дейкстры)
    - [Пример использования функции infix_to_postfix](#пример-использования-функции-infix_to_postfix)
5. [Калькулятор постфиксной нотации](#калькулятор-постфиксной-нотации)
    - [Описание кода калькулятора постфиксной нотации](#описание-кода-калькулятора-постфиксной-нотации)
6. [Построение графика](#построение-графика)
    - [Описание кода](#описание-кода)
7. [Пример использования](#пример-использования)

## Особенности

### 1. Преобразование из инфиксной в постфиксную нотацию

- **Поддерживаемые математические операторы:**
  - `+`, `-` (унарный и бинарный)
  - `*`, `/`, `^`

- **Поддерживаемые функции:**
  - `sin`, `cos`, `tan`, `cot`, `sqrt`, `ln`

- **Описание:**
  - Выражение преобразуется с использованием стека для операторов.

### 2. Вычисление постфиксного выражения

- **Поддерживаемые математические операторы:**
  - `+`, `-` (бинарный), `~` (унарный)
  - `*`, `/`, `^`

- **Поддерживаемые функции:**
  - `sin`, `cos`, `tan`, `cot`, `sqrt`, `ln`

- **Описание:**
  - Выражение вычисляется с использованием стека для операндов.

### 3. Построение графиков

- **Функциональность:**
  - Вычисляет массив значений для выражения в заданном диапазоне.
  - Строит простой график с использованием текстовых символов в терминале.

## Структура проекта

```plaintext
polish_notation/
├── build/                  # Папка для исполняемых файлов
│   └── (создаётся автоматически при сборке с помощью Makefile)
├── images/                 # Папка для изображений, используемых в README
├── README.md               # README на английском языке
├── README_RUS.md           # README на русском языке
└── src/                    # Исходный код проекта
    ├── dejkstra_alg/       # Реализация алгоритма Дейкстры
    ├── graph/              # Модуль для построения графиков
    ├── input/              # Модуль для ввода выражения
    ├── objs/               # Папка для объектных файлов
    ├── polish_calc/        # Модуль для расчёта выражений в постфиксной нотации
    ├── stack/              # Реализация стека
    ├── whotype/            # Вспомогательные функции (аналог ctype)
    ├── main.c              # Точка входа в программу, вызывает основные функции
    └── Makefile            # Makefile для сборки проекта
```

## Ввод исходной строки

`./src/input/`

Для ввода исходной строки, которая будет обработана, используются функции, описанные в файлах `input_expr.c` и `input_expr.h`. Основная функция для ввода:

- **`input_expr(char **const str)`**: Принимает указатель на строку, в которую будет записано введённое выражение. Возвращает длину строки. Возможные коды возврата:
  - `0`: Строка пуста
  - `-1`: Ошибка выделения памяти

Для упрощения работы с выражением можно опускать знак умножения между числами и функциями или переменными (`4x`, `5sin(0.5x)`). Для этого реализованы следующие функции:

- **`int space_clear(char **const str, int const len)`**: Удаляет лишние пробелы из строки. Пример: преобразует `2 sin(x)` в `2sin(x)`, но `4 4` оставляет без изменений.

- **`int insert_mul(char **const str, int const len)`**: Вставляет пропущенные знаки умножения в выражениях, где это необходимо. Пример: преобразует `4x` в `4*x`.

Также предусмотрена функция для вывода ошибок:

- **`input_err(int const err_code)`**: Выводит в стандартный поток ошибок код ошибки и её описание.

## Алгоритм Дейкстры - Конвертация инфиксной записи в постфиксную

В проекте реализован алгоритм Дейкстры для преобразования математических выражений из инфиксной записи в постфиксную (обратную польскую нотацию).

### Проверка логической корректности выражения

В модуле `expr_logic_check.c` реализована функция:

```c
int check_expression(char const *const original_expression,
                     char const *const modified_expression);
```

Функция принимает исходное выражение и модифицированное выражение, выполняя проверку на логическую корректность. Проверка включает:

- **Игнорирование пробелов:** Пробелы пропускаются.
  - Пример:
    - `2+2 *2` — корректно
    - `2+2 2` — ошибка
- **Баланс скобок:** Количество открывающих и закрывающих скобок должно совпадать.
- **Корректные символы:** Допускаются только цифры, операторы `+`, `-` (бинарный и унарный), `*`, `/`, `^`, `~`, а также функции `sin`, `cos`, `tan`, `cot`, `sqrt`, `ln`.
- **Проверка порядка:**
  - Первым элементом не может быть бинарный оператор (`+2` — ошибка)
  - После каждого операнда должен идти бинарный оператор или конец выражения
  - После каждого бинарного оператора не должен идти ещё один бинарный оператор
  - Унарных минусов может быть любое количество (`----5` — ошибка)

### Реализация алгоритма Дейкстры

`./src/dejkstra_alg/`

В файле `dejkstra.c` реализован сам алгоритм Дейкстры в функции:

```c
char *infix_to_postfix(char const *const infix);
```

Эта функция принимает строку в инфиксной форме и возвращает строку в постфиксной форме, где все элементы (операнды и операторы) разделены пробелами, или `NULL` в случае ошибок.

#### Основной код конвертации

```c
char *infix_to_postfix(char const *const infix) {
    char const *const modified_infix = replace_unary_minus(infix);
    if (!modified_infix)
        return NULL;

    if (!check_expression(infix, modified_infix)) {
        free((void *)modified_infix);
        return NULL;
    }

    char const *const postfix = do_postfix_convert(modified_infix);

    free((void *)modified_infix);
    return (char *const)postfix;
}
```

#### Описание работы кода

1. **Замена Унарного Минуса:**

   Функция `replace_unary_minus` обрабатывает выражение, заменяя унарные минусы специальным символом (`~`), чтобы избежать путаницы с бинарным минусом. Это необходимо, например, при конвертации выражения `2/(-1+2)`.

2. **Проверка Выражения:**

   После замены унарного минуса, функция `check_expression` проверяет корректность выражения.

3. **Конвертация в Постфиксную Форму:**

   Если выражение корректно, вызывается функция `do_postfix_convert` для непосредственной конвертации.

   ```c
   char *do_postfix_convert(char const *const modified_infix) {
       Stack_int operator_stack;
       initStack_int(&operator_stack);

       int const length = strlen(modified_infix);
       char *const postfix = (char *)malloc(4 * length * sizeof(char));
       if (!postfix) {
           return NULL;
       }

       int i = 0, j = 0;
       while (modified_infix[i] != '\0') {
           if (isSpace(modified_infix[i])) {
               i++;
               continue;
           }

           if (isDigit(modified_infix[i])) {
               parse_digits(modified_infix, &i, postfix, &j);
           } else if (isLetter(modified_infix[i])) {
               parse_letter(modified_infix, &i, postfix, &j, &operator_stack);
           } else if (isOperator(modified_infix[i]) || modified_infix[i] == '(' ||
                      modified_infix[i] == ')') {
               parse_operator_parentheses(modified_infix, &i, postfix, &j,
                                          &operator_stack);
           }
       }

       pop_until_empty(&operator_stack, postfix, &j);
       postfix[j] = '\0';

       destroyStack_int(&operator_stack);
       return postfix;
   }
   ```

4. **Разбор и обработка токенов:**

   - **Цифры:**
     - Функция `parse_digits` обрабатывает числовые значения и добавляет их в постфиксную строку.

   - **Функции и Переменные:**
     - Функция `parse_letter` обрабатывает функции (`sin`, `cos` и т.д.) и переменные, добавляя переменные в постфиксную строку или функции в стек операторов.

   - **Операторы и Скобки:**
     - **Открывающая скобка `(`:**
       - Помещается в стек операторов.
     - **Закрывающая скобка `)`**:
       - Извлекаются операторы из стека до `(` и добавляются в постфиксное выражение.
     - **Операторы (`+`, `-`, `*`, `/`, `^`, `~`):**
       - Обрабатываются с учётом приоритета и ассоциативности.

5. **Извлечение оставшихся операторов из стека:**

   После обхода всей строки, оставшиеся операторы извлекаются из стека и добавляются в постфиксную строку.

### Пример использования функции `infix_to_postfix`

Рассмотрим работу алгоритма на примере выражения `-2*ln(x)/(4*-2*sin(5*x))`.

1. **Замена унарных минусов:**

   **Исходное выражение:**
   ```
   -2ln(x)/(4-2sin(5x))
   ```

   **Модифицированное выражение:**
   ```
   ~2ln(x)/(4~2sin(5x))
   ```

2. **Пошаговый разбор:**

| Шаг | Текущий Символ | Действие                                                                                                                                                                                                                      | Постфиксная Строка               | Стек Операторов           |
|-----|----------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------|---------------------------|
| 1   | `~`            | **Оператор `~` (унарный минус):** Помещается в стек операторов.                                                                                                                                                           | ""                                | `[~]`                     |
| 2   | `2`            | **Операнд `2`:** Добавляется в постфиксную строку.                                                                                                                                                                       | `2 `                              | `[~]`                     |
| 3   | `*`            | **Оператор `*`:** Приоритет `*` (3) выше, чем у `~` (2). Оператор `*` помещается в стек.                                                                                                                                | `2 `                              | `[~, *]`                  |
| 4   | `l`            | **Функция `ln`:** Читается как целый токен `ln` и помещается в стек операторов.                                                                                                                                             | `2 `                              | `[~, *, ln]`              |
| 5   | `(`            | **Открывающая скобка `(`:** Помещается в стек операторов.                                                                                                                                                                  | `2 `                              | `[~, *, ln, (]`           |
| 6   | `x`            | **Операнд `x`:** Добавляется в постфиксную строку.                                                                                                                                                                       | `2 x `                            | `[~, *, ln, (]`           |
| 7   | `)`            | **Закрывающая скобка `)`:** Извлекаются операторы из стека до `(`.<br> - Извлекается и добавляется `ln`.<br> - Удаляется `(` из стека.                                                                                    | `2 x ln `                         | `[~, *]`                  |
| 8   | `/`            | **Оператор `/`:** Приоритет `/` (3) равен приоритету `*` (3). Поскольку `/` левосторонний:<br> - Извлекается `*` и добавляется в постфиксную строку.<br> - Затем `/` помещается в стек.                                 | `2 x ln * `                       | `[~, /]`                  |
| 9   | `(`            | **Открывающая скобка `(`:** Помещается в стек операторов.                                                                                                                                                                  | `2 x ln * `                       | `[~, /, (]`               |
| 10  | `4`            | **Операнд `4`:** Добавляется в постфиксную строку.                                                                                                                                                                       | `2 x ln * 4 `                     | `[~, /, (]`               |
| 11  | `*`            | **Оператор `*`:** Приоритет `*` (3) выше, чем у `(`. Оператор `*` помещается в стек.                                                                                                                                        | `2 x ln * 4 `                     | `[~, /, (, *]`            |
| 12  | `~`            | **Оператор `~`:** Приоритет `~` (2) ниже, чем у `*` (3).<br> - Извлекается `*` и добавляется в постфиксную строку.<br> - `~` помещается в стек.                                                                        | `2 x ln * 4 * `                   | `[~, /, (, ~]`            |
| 13  | `2`            | **Операнд `2`:** Добавляется в постфиксную строку.                                                                                                                                                                       | `2 x ln * 4 * 2 `                 | `[~, /, (, ~]`            |
| 14  | `*`            | **Оператор `*`:** Приоритет `*` (3) выше, чем у `~` (2). Оператор `*` помещается в стек.                                                                                                                                | `2 x ln * 4 * 2 `                 | `[~, /, (, ~, *]`         |
| 15  | `s`            | **Функция `sin`:** Читается как целый токен `sin` и помещается в стек операторов.                                                                                                                                          | `2 x ln * 4 * 2 `                 | `[~, /, (, ~, *, sin]`    |
| 16  | `(`            | **Открывающая скобка `(`:** Помещается в стек операторов.                                                                                                                                                                  | `2 x ln * 4 * 2 `                 | `[~, /, (, ~, *, sin, (]`  |
| 17  | `5`            | **Операнд `5`:** Добавляется в постфиксную строку.                                                                                                                                                                       | `2 x ln * 4 * 2 5 `               | `[~, /, (, ~, *, sin, (]`  |
| 18  | `*`            | **Оператор `*`:** Приоритет `*` (3) выше, чем у `(`. Оператор `*` помещается в стек.                                                                                                                                        | `2 x ln * 4 * 2 5 `               | `[~, /, (, ~, *, sin, (, *]`|
| 19  | `x`            | **Операнд `x`:** Добавляется в постфиксную строку.                                                                                                                                                                       | `2 x ln * 4 * 2 5 x `             | `[~, /, (, ~, *, sin, (, *]`|
| 20  | `)`            | **Закрывающая скобка `)`:** Извлекаются операторы из стека до `(`.<br> - Извлекается `*` и добавляется в постфиксную строку.<br> - Извлекается `sin` и добавляется в постфиксную строку.<br> - Удаляется `(` из стека. | `2 x ln * 4 * 2 5 x * sin `        | `[~, /, ~]`               |
| 21  | Конец выражения | **Завершение обхода:** Извлекаются оставшиеся операторы из стека и добавляются в постфиксную строку.<br> - Извлекается `/` и добавляется.<br> - Извлекается `~` и добавляется.                                    | `2 x ln * 4 * 2 5 x * sin / ~`     | `[]`                      |

**Итоговое постфиксное выражение:**
```
2 x ln * 4 * 2 5 x * sin / ~
```

## Калькулятор постфиксной нотации

`./src/polish_calc`

Функция `int polish_calc(char const *const postfix, double *const result)` предназначена для вычисления значения выражения, записанного в постфиксной (обратной польской) нотации. Она принимает строку с постфиксным выражением и адрес переменной типа `double`, куда будет записан результат. Возвращает один из кодов ошибки:

- `1`: Нет ошибки
- `-1`: Деление на ноль
- `-2`: Корень из отрицательного числа
- `-3`: Логарифм из неположительного числа
- `-4`: Неизвестный оператор
- `-5`: Неизвестная функция

### Описание кода калькулятора постфиксной нотации

1. **Инициализация стека:**
   - Создаётся и инициализируется стек `operandStack` для хранения операндов.

2. **Разделение строки на токены:**
   - Строка разделяется на токены с использованием пробела как разделителя с помощью `strtok`.

3. **Обработка токенов:**
   - **Числа:**
     - Если токен начинается с цифры, он преобразуется в `double` с помощью `atof` и помещается в стек операндов.

   - **Унарный минус (`~`):**
     - Извлекается верхний операнд из стека, применяется отрицание, и результат возвращается в стек.

   - **Бинарные операторы (`+`, `-`, `*`, `/`, `^`):**
     - Извлекаются два верхних операнда из стека.
     - Применяется соответствующая операция через функцию `apply_operator`.
     - Результат операции помещается обратно в стек, если не возникло ошибок.

   - **Функции:**
     - Если токен является известной функцией, извлекается верхний операнд, применяется функция через `apply_function`, и результат возвращается в стек.
     - Если функция неизвестна, устанавливается код ошибки `ERROR_UNKNOWN_FUNCTION`.

4. **Получение итогового результата:**
   - Если не возникло ошибок, извлекается итоговый результат из стека и сохраняется в переменную `result`.
   - Возвращается код ошибки.

## Построение графика

`./src/graph/`

Модуль `plot_graph.c` предназначен для отображения графика математических функций в консоли. Графики строятся на основе постфиксных выражений (обратной польской записи), которые вычисляются для различных значений переменной `x`. Результаты визуализируются в консоли с использованием текстовых символов.

### Описание кода

1. **`int plot_graph(char const *const postfixExpression)`**

   - **Основная функция** для запуска процесса построения графика.
   - Принимает **постфиксное выражение**, представляющее математическую функцию от `x`, и выводит её график в консоли.
   - **Диапазоны по умолчанию:**
     - `x_min = -20`, `x_max = 20`
     - `y_min = -10`, `y_max = 10`
   - **Генерация точек:**
     - Вызывает функцию `gen_points` для вычисления точек графика на основе выражения и диапазона `x`.
     - Получает массив точек и количество вычисленных точек.
   - **Отрисовка графика:**
     - Проходит по каждой строке (`y`) и столбцу (`x`) консоли в пределах `GRAPH_HEIGHT` и `GRAPH_WIDTH`.
     - Для каждой позиции вызывает `graph_draw_cns`, которая определяет, какой символ отображать в этой позиции.
   - **Вывод диапазонов:** После построения графика выводит диапазоны значений `x` и `y`.
   - **Освобождение памяти:** Освобождает память, выделенную для массива точек.
   - **Возврат значения:** Возвращает `1` при успешном выполнении.

2. **`Point *gen_points(char const *const postfixExpression, int const x_min, int const x_max, int *const num_points)`**

   - Генерирует массив точек (`Point`) для графика на основе заданного выражения и диапазона `x`.
   - **Вычисление шага по оси `x`:** Определяет, насколько изменяется `x` при каждом шаге, исходя из ширины графика и диапазона `x`.
   - **Инициализация счётчика:** Устанавливает начальное значение количества точек (`*num_points`) в `0`.
   - **Вычисление значений:**
     - Для каждого шага по `x`:
       - Вычисляет конкретное значение `x_value` на основе текущего шага.
       - Вызывает `evaluate_postfix_expression` для вычисления соответствующего `y_value`, заменяя все вхождения `x` на текущее `x_value`.
       - Если вычисление успешно (`ERROR_NONE`), сохраняет точку в массив и увеличивает счётчик точек.
   - **Возврат массива:** Возвращает указатель на массив с вычисленными точками.

3. **`void graph_draw_cns(char const *const postfixExpression, int const x_min, int const x_max, int const y_min, int const y_max, int const x, int const y)`**

   - **Отвечает за отрисовку** конкретного символа на позиции `(x, y)` консоли, представляя как оси координат, так и саму функцию.
   - **Создаёт визуальное представление** графика, определяя, какой символ должен отображаться в каждой позиции.
   - **Вычисляет масштаб:**
     - Определяет `x_scale` и `y_scale` для преобразования координат из математических в консольные.
   - **Определяет нулевые оси:**
     - Вычисляет позиции `y_zero` и `x_zero` для осей `y` и `x`, соответственно.
   - **Определяет символ:**
     - Если позиция совпадает с пересечением осей, устанавливает символ `'+'`.
     - Если позиция находится на оси `y`, устанавливает символ `'|'`.
     - Если позиция находится на оси `x`, устанавливает символ `'-'`.
   - **Отображает функцию:**
     - Вычисляет значение функции для текущего `x`.
     - Определяет позицию `y` для этого значения.
     - Если позиция `y` близка к текущей позиции `y` в консоли (с учётом `DELTA`), устанавливает символ `'*'`.

4. **`char *replace_x_with_value(char const *const str, double const value)`**

   - **Заменяет переменную `x`** в строковом выражении на конкретное числовое значение `value`.

## Пример использования

![Пример изображения](images/funcsTest01.png)
